-------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use work.router_lib.all;


entity router_top is
generic( numberOfDSP: integer := numberOfDSP);
port (
	clk			: in STD_LOGIC;	
	rst 			: in STD_LOGIC;
	enable 			: in STD_LOGIC;
	first			: in STD_LOGIC;
	features		: in STD_LOGIC_VECTOR(15 DOWNTO 0);
	size_output		: in STD_LOGIC_VECTOR(15 DOWNTO 0);
	data_in			: in input_router;
	valid			: in STD_LOGIC_VECTOR(15 DOWNTO 0);
	
	ready_router		: out STD_LOGIC;
	output			: out output_router
);
end entity;

architecture behavioral of router_top is 
	signal ready_counter_i: STD_LOGIC_VECTOR(numberOfDSP - 1 downto 0);
	signal valid_i : STD_LOGIC_VECTOR(numberOfDSP - 1 downto 0);
	type data_buffer is array (199 downto 0) of BRAM_block;
	signal data: data_buffer;
 	signal data_buffer_mux: data_buffer;
	signal counter_kernel: integer;
	signal valid_q: STD_LOGIC_VECTOR(15 DOWNTO 0);
	signal valid_qq: STD_LOGIC_VECTOR(15 DOWNTO 0);
	signal offset: integer;
	begin
	
	process (clk) 
	begin
		for I in 0 to 196 loop
			if rst = '1' then 
				data(i)(0)(15 downto 0) <= (others => '0');
				data(i)(1)(15 downto 0) <= (others => '0');  
				data(i)(2)(15 downto 0) <= (others => '0'); 
				counter_kernel <= 0;
			elsif rising_edge (clk) then	
				if first = '1' then
					data(i)(0)(15 downto 0) <= data_in(i)(15 downto 0);
					data(i)(1)(15 downto 0) <= data_in(i+1)(15 downto 0);
					data(i)(2)(15 downto 0) <= data_in(i+2)(15 downto 0);
				end if;	
				if valid_i(0) = '1' then 
					if counter_kernel = 2 then
						counter_kernel <= 0;
					else  
						counter_kernel <= counter_kernel + 1;
					end if;
				end if;	
			end if;	
		end loop;
	end process; 
	
	 
		

	process (data, size_output, counter_kernel)
	begin
		for I in 0 to 100 loop
			case size_output is
				when std_logic_vector(to_unsigned(32,16)) => 
					case counter_kernel is
						when 0 =>
							if I > 61 then 
								data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(I + 4)(2 downto 0)(15 downto 0);
							elsif I > 29 then 
								data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(I + 2)(2 downto 0)(15 downto 0);
							else 
								data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(I)(2 downto 0)(15 downto 0);
							end if;
						when 1 => 
							data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(32+I)(2 downto 0)(15 downto 0);
						when 2 => 
							data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(64+I)(2 downto 0)(15 downto 0);
						when others => 
							data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(I)(2 downto 0)(15 downto 0);
					end case;				
				when std_logic_vector(to_unsigned(14,16)) => 
					case counter_kernel is
						when 0 => 
							data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(I)(2 downto 0)(15 downto 0);
						when 1 => 
							data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(14+I)(2 downto 0)(15 downto 0);
						when 2 => 
							data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(28+I)(2 downto 0)(15 downto 0);
						when others => 
							data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(I)(2 downto 0)(15 downto 0);
					end case;
			when std_logic_vector(to_unsigned(5,16)) => 
					case counter_kernel is
						when 0 => 
							data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(I)(2 downto 0)(15 downto 0);
						when 1 => 
							data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(5+I)(2 downto 0)(15 downto 0);
						when 2 => 
							data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(10+I)(2 downto 0)(15 downto 0);	
						when others =>
							data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(I)(2 downto 0)(15 downto 0); 
					end case;	
			when others => 
				data_buffer_mux(I)(2 downto 0)(15 downto 0) <= data(I)(2 downto 0)(15 downto 0);
				end case;
		end loop;
	end process;
	
	
	process (clk)
	begin
		if rst = '1' then 
			valid_q(15 downto 0) <= (others => '0');
			valid_qq(15 downto 0) <= (others => '0');
		elsif rising_edge(clk) then 
			valid_q(15 downto 0) <= valid(15 downto 0);
			valid_qq(15 downto 0) <= valid_q(15 downto 0);
		end if;
	end process;

	process (valid, valid_q, valid_qq)
	begin
		for I in 0 to (numberOfDSP - 1) loop
			if (i mod 200) < to_integer(unsigned(valid)) or (i mod 200) < to_integer(unsigned(valid_q)) or (i mod 200) < to_integer(unsigned(valid_qq)) then 
				valid_i(i) <= '1'; 
			else 
				valid_i(i) <= '0';
			end if;
		end loop;
	end process;
	process (ready_counter_i)
	begin
		ready_router <= '1'; 
		for I in 0 to 399 loop 
			if ready_counter_i(i) = '0' then 
				ready_router <= '0';
			end if;
		end loop;
	end process;
	datapath: for I in 0 to (numberOfDSP - 1) generate
	
	router: entity work.router(behavioral)
		Port Map(	
			clk			=> clk,	
			rst 			=> rst,
			enable 			=> enable,
			valid			=> valid_i(i),
			dataIn1			=> data_buffer_mux(I mod 100)(0)(15 downto 0),
			dataIn2			=> data_buffer_mux(I mod 100)(1)(15 downto 0),
			dataIn3			=>data_buffer_mux(I mod 100)(2)(15 downto 0),
	
			ready_router		=>ready_counter_i(i),
			output			=> output(i));
	
	end generate datapath;
	end architecture;
